# CH.05 책임 할당하기

### 책임 주도 설계

1. 책임 주도 설계를 위해서는 아래 두 규칙을 따라야 한다.
    1. 데이터보다 행동을 먼저 결정하라.
    2. 협력이라는 문맥 안에서 책임을 결정하라.

### 데이터보다 행동을 먼저 결정하라

1. 객체에게 중요한 것은 외부에 제공하는 행동. 객체가 수행하는 행동이란 곧 객체의 책임이다.
2. 데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐이다.
3. “이 객체가 수행해야 하는 책임은 무엇인가?”를 결정한 후 “이 책임을 수행하는 데 필요한 데이터는 무엇인가?”를 결정해야 한다.
4. 적절한 객체에게 적절한 책임을!

### 협력이라는 문맥 안에서 책임을 결정하라

1. 협력에 적합한 책임이란 메시지 수신자가 아닌 메시지 전송자에게 적합한 책임을 의미한다.
2. 메시지가 객체를 선택하게 해야 한다.
3. 송신자는 수신자에 대해 어떠한 가정도 할 수 없기 때문에, 클라이언트는 전송할 메시지를 결정한 후에야 객체의 상태를 저장하는 데 필요한 내부 데이터에 대해 고민할 수 있다.

### 도메인 개념에서 출발하기

1. 도메인을 책임 할당 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 쉬워진다.
2. 어떤 책임을 할당해야 할 때, 가장 먼저 고민해야 하는 유력한 후보는 도메인 개념이다.

### 정보 전문가에게 책임을 할당하라

1. 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 한다.
2. 아래 두 질문을 고민해 보아야 한다.
    1. 메시지를 전송할 객체는 무엇을 원하는가?
    2. 메시지를 수신할 적합각 객체는 누구인가?
    3. → 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당해야 한다. 이를 Information Expert(정보 전문가) 패턴이라고 한다.
3. Information Expert 패턴은 객체가 자신이 소유하고 있는 정보와 관련된 작업을 수행한다는 직관을 표현한 것이다. 
4. 이때, 책임을 수행하는 객체가 정보를 ‘알고' 있다고 해서 그 정보를 ‘저장'하고 있을 필요는 없다. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다.

### 높은 응집도와 낮은 결합도

1. 설계는 트레이드오프 활동이다. → 여러 가지 설계 중 한 가지를 선택해야 하는 경우가 빈번하게 발생한다. 
2. 이때, 여러 설계 중 높은 응집도와 낮은 결합도를 얻을 수 있는 설계를 선택해야 한다.
3. Low Coupling(낮은 결합도) 패턴, High Cohesion (높은 응집도) 패턴을 고려해야 한다.

### 창조자에게 객체 생성 책임을 할당하라

1. Creator(창조자) 패턴: 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.
2. 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.
    1. B가 A 객체를 포함하거나 참조한다.
    2. B가 A 객체를 기록한다.
    3. B가 A 객체를 긴밀하게 사용한다.
    4. B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (이 경우 B는 A에 대한 정보 전문가다.)
3. Creator 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다. 생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다. 즉, 두 객체는 서로 결합된다.

### 변경의 이유에 따라 클래스를 분리해야 한다

1. 설계 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다. 
2. 인스턴스 변수가 초기화되는 시점을 살펴본다. 
    1. 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다. 반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다. 클래스의 속성이 서로 다른 시점에 초기화되거나 일부만 초기화된다는 것은 응집도가 낮다는 증거이다. 따라서 `함께 초기화되는 속성을 기준으로 코드를 분리해야 한다`.
3. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴본다.
    1. 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다. 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다. 클래스의 응집도를 높이기 위해서는 `속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다`.
4. 클래스 응집도 판단하기
    1. 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라.
    2. 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.
    3. 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라.

### 다형성을 통해 분리하기

1. 객체의 암시적인 타입에 따라 행동을 분기해야 한다면 암시적인 타입을 명시적인 클래스로 정의하고, 행동을 나눔으로써 응집도 문제를 해결할 수 있다.
2. 즉, 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라. → Polymorphism(다형성) 패턴
3. Polymorphism(다형성) 패턴: if ~ esle or switch ~ case 등의 조건 논리를 사용해서 설계한다면 새로운 변화가 일어난 경우 조건 논리를 수정해야 한다. → 변경에 취약함.

### 변경으로부터 보호하기

1. Protected Variations(변경 보호) 패턴: 변경을 캡슐화하도록 책임을 할당하는 것. 변경될 가능성이 높으면 캡슐화하라.

### 책임 주도 설계의 대안

1. 책임 관점에서 사고하기 위해서는 충분한 경험과 학습이 필요하다.
2. 그러니까 일단 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하고 후에 수정한다.
3. 코드를 수정한 후에는 겉으로 드러나는 동작이 바뀌어서는 안 된다.
4. 리팩토링:  이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것.
5. 객체로 책임을 분배할 때 가장 먼저 할 일은 메서드를 응집도 있는 수준으로 분해하는 것이다. 긴 메서드를 작고 응집도 높은 메서드로 분리하면 각 메서드를 적절한 클래스로 이동하기가 더 수월해지기 때문이다.

### 객체를 자율적으로 만들자

1. 어떤 메서드를 어떤 클래스로 이동시켜야 할까? → 객체는 자율적인 존재이니까 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 길이다. 
2. 즉, 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 된다.
