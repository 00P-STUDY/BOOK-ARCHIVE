# 책임 할당하기
> 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기 쉽지 않다는 것이다. 이번 장에서 살펴볼 GRASP 패터늘 이해하면 응집도와 결합도, 캡슐화 같은 다양한 기준에 따라 책임을 할당하고 결과를 트레이드오프할 수 있는 기준을 배우게 될 것이다.

## 1. 책임 주도 설계를 향해
1. 데이터보다 행동을 먼저 결정해라
2. 협력이라는 문맥 안에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정해라
- 데이터에 초점을 맞추면 객체의 캡슐화가 약화되기 때문에 낮은 응집도와 높은 결합도를 가진 객체들로 넘쳐나게 된다. 즉, 변경에 취약한 설계가 된다.

- 가장 기본적인 해결방안은 객체를 설계하기 위한 질문의 순서를 바꾸는 것
- **이 객체가 수행해야하는 책임은 무엇인가? -> 이 책임을 수행하는 데 필요한 데이터는 무엇인가?**
- 그렇다면 객체에게 어떤 책임을 할당해야 할까?

### 협력이라는 문맥 안에서 책임을 결정하라
- 객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것
- 객체의 입장에서 책임이 어색해보이더라도, **협력에 적합하다면 좋은 책임이다.**

> 이 클래스가 필요한지는 알겠는데, 무엇을 해야하지? => 메시지를 전송해야 하는데 누구에게 전송해야 하지? 로 메시지 기반, 책임 기반 설계로 향하는 첫걸음

- 캡슐화의 관점에서 메시지를 먼저 결정해버리면 해당 메시지 수신자에 대한 어떠한 가정도 할 수 없다. **즉, 수신자가 깔끔하게 캡슐화가 가능해진다.**

## 2. 책임 할당을 위한 GRASP 패턴
- GRASP : General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴) : **객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것**

### 도메인 개념에서 출발하기
- 설계 시작 전 도메인에 대한 개략적인 모습을 그려보는 것은 유용
- 이 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 좀 더 수월해진다.
- **책임 할당 시 가장 먼저 고민해야 하는 후보는 도메인 개념!**

### 정보 전문가에게 책임을 할당하라
- 어플리케이션이 제공해야 하는 기능을 어플리케이션의 책임으로 생각하기
- 영화를 예매하는 것 => app은 영화를 예매할 책임이 있다.
- 메시지를 전송할 객체는 무엇을 원하는가? = 예매하라
- 메시지를 수신할 적합한 객체는 누구인가?
  - **책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.**
  - **=> INFORMATION EXPERT(정보 전문가) 패턴**
- 책임을 수행하는 데 필요한 정보를 갖고 있는 객체에게 할당하는 사실은 객체가 자율적인 존재여야 한다는 사실을 다시 한번 상기시킨다. 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있기 때문이다. **결과적으로 정보와 행동을 묶기 때문에 캡슐화가 유지되고 높은 응집도가 가능하다.**
- 하지만 **정보를 알고 있다고 해서 저장하고 있을 필요**는 없다. 
- 따라서 정보 전문가 패턴에 따르면 예매하는 데 필요한 정보를 가장 많이 알고 있는 객체는 '상영'이라는 도메인 개념이 적합하다.
- 상영에서 예매 가격을 계산 => 가격을 계산하라라는 새로운 메시지 : 영화 도메인
- 영화에서 할인 여부를 판단 => 할인 여부를 판단하라는 새로운 메시지 : 할인 조건
- 할인 조건에서는 모든 정보를 갖고 있기 때문에 리턴
> **정보 전문가 패턴을 따르는 것만으로도 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아지는 것**

### 높은 응집도와 낮은 결합도
- LOW COUPLING 패턴 : 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라
- HIGH COHESION 패턴 : 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가

### 창조자에게 객체 생성 책임을 할당하라
- 영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것 => 협력에 참여하는 어떤 객체에게는 Reservation 인스턴스를 생성할 책임을 할당해야한다는 것을 의미
- **CREATOR(창조자) 패턴은 이 같은 경우에 사용할 수 있는 책임 할당 패턴으로서 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공**

```
B가 A 객체를 포함하거나 참조한다
B가 A 객체를 기록한다
B가 A 객체를 긴밀하게 사용한다
B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다 (이 경우 B는 A에 대한 정보 전문가이다)
```
**아래의 조건을 최대한 많이 만족하는 B에게 객체 A를 생성하는 책임을 할당하자.**

## 3. 구현을 통한 검증
- 낮은 응집도가 초래하는 문제를 해결하기 위해서는 **변경의 이유에 따라 클래스를 분리해야 한다.**
- 일반적으로 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작한다

### 코드를 통해 변경의 이유를 파악
1. 인스턴스 변수가 초기화되는 시점을 살펴보기
   - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
   - 함께 초기화되는 속성을 기준으로 코드를 분리하기
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보기
   - 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.
   - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리하기

### 다형성을 통해 분리하기
- 역할은 협력 안에서 대체 가능성을 의미하기 때문에 구체 클래스를 알지 못하게 하고 오직 역할에 대해서만 결합되도록 의존성을 제한 가능
- 역할을 사용하면 객체의 구체적인 타입을 추상화할 수 있다.
> 다형성 패턴 : 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하자

### 변경으로부터 보호하기
- 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하기
> 변경 보호 패턴 : 변경을 캡슐화하도록 책임을 할당하는 것

- 클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하는 것은 설계의 결합도와 응집도를 향상시키는 매우 강력한 방법
- 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 POLYMORPHISM 패턴에 따라 책임을 분산
- 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 PROTECTED VARIATIONS 패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화

## 4. 책임 주도 설계의 대안
- 몬스터 메서드와 같이 길이가 매우 긴 메서들을 리팩터링해보자
- 메서드를 작게 분해해서 각 메서드의 응집도를 높이자
- 긴 메서드를 작고 응집도 높은 메서드로 분리하면 각 메서드를 적절한 클래스로 이동하기가 더 수월해진다.
