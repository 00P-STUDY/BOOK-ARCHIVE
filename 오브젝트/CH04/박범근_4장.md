# 설계 품질과 트레이드 오프
> 책임 주도 설계 : 역할, 책임, 협력 중에서 가장 중요한 것은 '책임'

## 객체지향 설계
1. 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 것
2. 객체지향의 설계의 핵심은 책임
3. 책임을 할닿아는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관
- 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결홥돼 있는 요소로 구성된다.
- 그러기 위해선 객체의 상태에 집중하는 것이 아닌, 객체의 책임에 초점을 맞춘다.

## 데이터 중심의 영화 예매 시스템 (상태 중심의 나쁜 설계)
- 데이터 중심의 설계는 **자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션**을 정의한다.
- 책임 중심의 설계는 **다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태**를 보관한다.

### 데이터 중심 설계
- 객체의 상태는 구현에 속하는데, 구현은 불안정하기 때문에 변하기 쉽다
- => 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되며 캡슐화가 무너진다
- => 결과적으로 상태 변경이 되면, 연관된 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체의 변경까지 초래하게 된다.

### 책임 중심 설계
- 책임을 드러내는 안정적인 인터페이스를 기초로 설계를 한다
- => 이후 책임을 수행하는데 필요한 상태들을 인터페이스 안으로 캡슐화를 한다.
- => 이후 구현이 변경되어 상태를 변경해야해도 인터페이스 외부로 퍼져나가지 않는다.

### 데이터를 준비하자
- 데이터 중심의 설계는 데이터 기반으로 시스템을 분할, 객체 내부에 저장해야하는 '데이터가 무엇인가'로 시작한다.

## 설계 트레이드오프
 - 캡슐화, 응집도, 결합도 : 데이터 중심 설계 vs 책임 중심 설계의 장단점을 비교할 수 있는 매트릭스

### 캡슐화
- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서이다.
- 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절히 조절할 수 있는 장치를 제공
- 변경이 자주 되는 **구현**과 상대적으로 안정적인 **인터페이스** 중, 외부에서는 인터페이스만을 의존하도록 관계를 조절

> 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화 기법, 객체지향 설계의 핵심

- 요구사항이 변경돼도 두려움 없이 코드를 변경할 수 있는 유지보수성이 목표이다. 그리고 캡슐화가 부족하면 우리는 변경으로부터 자유로울 수 없다.

### 응집도
- 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타냄.
- 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타내는 척도

### 결합도
- 의존성의 정도를 나타내며, 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 갖음
- 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타냄

### 좋은 설계란?
- 높은 응집도와 낮은 결합도를 가진 설계
- 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계가 베스트
- 높은 응집도 : 변경을 수용하기 위해 **모듈 전체가 함께 변경**되거나 하나의 **모듈만 변경되는 경우** = 낮은 결합도
- 직접 작성한 코드는 항상 불안정하며 언제든지 변경될 수 있으므로 높은 응집도와 낮은 결합도를 지향해야함

## 데이터 중심의 영화 예매 시스템의 문제점

1. 캡슐화 위반
2. 높은 결합도
3. 낮은 응집도

### 캡슐화 위반
- 접근자와 수정자 메서드(get, set)은 캡슐화의 원칙을 지킬까?
- **getFee와 setFee는 Movie 내부에 Money 타입의 fee라는 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다.**
- 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문
- 과도한 접근자와 수정자에 의존하는 설계는 **추측에 의한 설계 전략**

### 높은 결합도
- 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미
- **더 나쁜 건 단지 객체의 내부 구현을 변경했지만, 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다는 것**
- 만약 getFee()에서 fee의 타입이 변경된다면 의존된 클래스들의 변경이 따름
- 사실 getFee 메서드를 사용하는 것은 인스턴스 변수 fee의 가시성을 private에서 public으로 변경하는 것과 동일
> 느낀점 : get을 통해서 밖으로 꺼내서 결합성을 올리지 말고 내부에서 응집도 있게 처리 후 메세지를 전달하자

### 낮은 응집도
- 변경된 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.
- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.

###  단일 책임 원칙(Single Responsibility Principle, SRP)
- 클래스는 단 한 가지의 변경 이유만 가져야 한다는 것 => 클래스의 응집도를 높일 수 있는 설계 원칙
- 여기서 책임은 객체지향의 책임이 아닌, 변경의 이유 = 여러 이유로 해당 클래스가 계속 바뀌면 안된다.

## 자율적인 객체를 향해
### 캡슐화를 지켜라
- 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 함. 물론, 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수애하는 메서드이다.

### 스스로 자신의 데이터를 책임지는 객체
- 객체가 스스로 자신의 상태를 처리할 수 있게끔
1. 이 객체가 어떤 데이터를 포함해야 하는가?
2. 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
- 이 두 질문을 조합해서 **객체의 내부 상태를 저장하는 방식**과 **저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합**을 얻을 수 있음 = 새로운 데이터 타입

## 하지만 여전히 부족하다
### 캡슐화 위반
- 설계를 변경해서 수정된 객체들은 자기 자신의 데이터를 스스로 처리한다.
- 하지만 파라미터를 보면, 내부 구현을 외부에 노출시키고 있다.
- 해당 속성 구현을 변경한다면? 파라미터 수정 및 해당 메서드를 사용하는 모든 클라이언트 역시 수정이 필요해진다.

> 캡슐화의 진정한 의미 : 내부 속성을 외부로 감추는 것은 '데이터 캡슐화'라고 불리는 한 종류일 뿐. **변할 수 있는 어떤 것**이라도 감춰야 진정한 캡슐화이다.

### 높은 결합도
- DiscountCondition의 구현이 변경되는 경우 해당 클래스에 의존하는 Movie를 변경해야 한다 => 결합도가 높다
- 내부 구현을 제대로 캡슐화하지 못했기 때문

### 낮은 응집도
- 하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 함

## 데이터 중심 설계의 문제점
- 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정

1. **데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다**
   - 데이터를 처리 후 필요한 오퍼레이션을 나중에 결정하는 경우 데이터에 관한 지식이 고스란히 객체의 인터페이스에 드러나게 됨

2. **데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.**
    - 협력이라는 문맥 안에서 필요한 책임을 결정하고 이를 수행할 적절한 객체를 결정하는 것이 중요
    - 데이터 중심 설계는 문맥에 깊은 이해보다는 객체가 관리할 데이터의 세부 정보를 먼저 결정
