# 1강

# 나쁜 코드

객체가 통제를 받는 수동적인 존재일 때

우리의 예상에서 크게 벗어나 있는 코드 - 현실과는 다른 코드

코드를 이해하기 위해 여러가지 세부사항을 이해하고 있어햐한다

한 객체를 변경할 때 다른 객체까지 변경해야하는 경우

- 의존성과 관련된 문제
- 변경에 대한 영향을 암시한다
- 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포됨

### 설계의 목표

객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것

### 객체를 자율적인 존재로 만든다

Teater가 Audience와 TicketSeller에 관해 세세한 부분까지 알지 못하도록 정보를 차단하는 것

### 캡슐화

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것

Theater은 오직 TicketSeller의 **인터페이스**에만 의존한다

TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 **구현**의 영역이다.

### 자율적인 객체를 위해서, 변경의 용이성을 위해

```jsx
하나의 객체에서 get으로 다른객체에 접근한다음 또 다른 메세지를(get,set,do)날린다면
의존정을 제거하자
```

### 좋은 설계?

오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용하는 설계

## 절차지향 vs 객체지향

### 절차지향

- Process와 Data를 별도의 모듈에 위치시킨다
- 모든 프로그램이 연결되어 있다(의존성)
    - 데이터의 변경으로 인한 영향을 모두가 받는다
- 변경하기 어렵다

절차지향언어는 개체를 순차적으로 처리하여 프로그램 전체가 유기적으로 연결되어야 합니다.

### 객체지향

- 객체 내부의 변경이 외부에 파급되지 않는다
- 책임이분산됨

### 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것