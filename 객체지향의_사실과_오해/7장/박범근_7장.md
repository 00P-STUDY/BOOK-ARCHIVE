# 함께 모으기

> 코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다.

## 객체지향 설계의 3가지 관점
### 개념 관점(Conceptual Perspective)
- 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현
- 사용자가 도메인을 바라보는 관점을 반영
- 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심

### 명세 관점(Specification Perspective)
- 도메인의 개념이 아닌 실제로 SW 안에서의 객체들의 책임에 초점을 맞춤
- 객체의 인터페이스(기능, 책임)을 바라보게 됨
- 객체가 협력을 위해 '무엇'을 할 수 있는지?에 대한 초점
  - 인터페이스와 구현을 분리하자.

### 구현 관점(Implementation Perspective)
- 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것
- 객체의 책임을 '어떻게' 수행할 것인지에 초점을 맞추고, 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다

1. 클래스의 은유 -> 도메인 관점
2. 클래스의 공용 인터페이스 -> 명세 관점
3. 클래스의 속성과 실제 내부 메서드 구현 -> 구현 관점

---

## 개념 설계
> 도메인 모델을 이용하여 해당 도메인을 구성하는 타입들의 종류와 관계를 표현하자

- 도메인 모델 : SW가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델
  - 관련된 객체들을 타입과 관계를 이용해서 추상화하자.
  

- 동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮추자
- 분류를 위해 타입을 사용하며, 상태와 무관하게 **동일한 행동을 하는 객체들**을 **동일한 타입의 인스턴스**로 분류한다.

- 합성(Composition), 포함(containment) : 어떤 객체가 다른 객체에 포함되는 관계
- 연관(Association) : 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 하는 관계

즉, 어떤 타입이 도메인을 구성하는지 & 타입들 사이에 어떤 관계가 존재하는지 파악

## 명세 설계
> 객체들 간 훌륭한 협력을 설계하기 위해선 메시지를 찾고, 적절한 객체를 선택하자.

- **메시지를 수신할 객체는 메시지를 처리할 책임**을 맡게 되고, **객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스**가 된다.
- 메시지를 찾고, 메시지를 처리하기에 적합한 객체를 선택
  - 해당 객체를 현실 객체에 은유하자
  - 모방이나 추상화가 아닌, 의미를 쉽게 유추하기 쉽게 '은유'하는 것

## 구현 설계
> 명세 설계에서 얻어낸 객체들의 인터페이스를 구현하자

- 객체가 어떤 메시지를 받을 수 있다는 것
    - 해당 객체가 해당 메시지를 처리할 수 있는 오퍼레이션이 있다는 것
1. 클래스를 이용하여 객체의 타입을 구현하고
2. 해당 타입에 맞는 오퍼레이션은 외부에서 접근이 가능하도록 public 인터페이스로 구현
3. 메서드를 통해서 오퍼레이션을 수행하는 방법 정의

- 객체의 속성을 캡슐화 하기 위해선?
  - **인터페이스에는 객체의 내부 속성에 대한 정보**가 있어선 안된다.
  - 즉, 인터페이스를 설계하는 단계에서 객체의 속성이나 어떤 자료 구조로 구현되는 지 등을 고려하지 않는 것
    - 고려한다는 것은 해당 설계에 그 정보들이 쓰이기 때문


# 코드와 세 가지 관점
## 왜 도메인 개념을 반영할까?
  - SW 클래스가 도메인 개념과 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있기 때문
  - 해당 비즈니스 로직이 바뀌지 않는 한 쉽게 변경되지 않는다.
  - 도메인 개념 안에서 적절한 객체를 선택함으로 도메인 지식 기반으로 코드의 구조와 의미를 쉽게 유추 가능

## 객체의 인터페이스는 수정하면 안될까?
- 공용 인터페이스는 외부의 객체들과 협력하는 부분이므로, 인터페이스가 바뀌는 순간 모든 객체에게 영향을 끼친다.
- 최대한 변화에 안정적인 인터페이스를 만들어야 하고, 그러기 위해선 **인터페이스에는 구현과 관련된 세부 사항이 드러나서는 안된다.**
  
## 메서드의 구현과 속성의 변경은?
- 외부의 객체에 영향을 끼쳐선 안된다.
- 메서드와 속성이 철저하게 클래스 내부로 캡슐화가 되어야 한다.
- 외부의 클래스는 자신이 협력하는 다른 클래스의 구현에 영향을 받아선 안된다.
  
> 인터페이스와 구현을 분리하자.
